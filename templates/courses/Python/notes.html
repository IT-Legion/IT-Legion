заметка на разбор
Декоратор @functools.wraps(func) используется для сохранения важной метаинформации о декорируемой функции. Когда вы создаете декоратор, функция-обёртка (wrapper) обычно заменяет оригинальную функцию, что может привести к потере информации о ней, такой как её имя, строка документации (docstring), аннотации типов и т.д.

@functools.wraps(func) помогает избежать этой проблемы, копируя метаданные из оригинальной функции в функцию-обёртку. Давайте рассмотрим, как это работает и почему это полезно:

Пример без @functools.wraps
python
Копировать код
import functools

def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("До вызова функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper

@my_decorator
def say_hello():
    """Эта функция говорит привет."""
    print("Привет!")

print(say_hello.__name__)  # Вывод: wrapper
print(say_hello.__doc__)   # Вывод: None
Без использования functools.wraps, имя и документация функции say_hello теряются, и вместо них отображаются соответствующие данные функции wrapper.

Пример с @functools.wraps
python
Копировать код
import functools

def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print("До вызова функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper

@my_decorator
def say_hello():
    """Эта функция говорит привет."""
    print("Привет!")

print(say_hello.__name__)  # Вывод: say_hello
print(say_hello.__doc__)   # Вывод: Эта функция говорит привет.
С использованием functools.wraps, имя и документация оригинальной функции say_hello сохраняются.

Почему это важно?
Удобство отладки и логирования:

Имя функции и её документация помогают при отладке кода и при анализе логов.
Сохранение аннотаций типов:

Важны для инструментов статического анализа кода и систем типов.
Работа с различными инструментами и библиотеками:

Некоторые библиотеки и инструменты (например, автодокументирование) зависят от наличия правильной информации о функции.
Что делает functools.wraps?
Внутри functools.wraps вызывает функцию functools.update_wrapper, которая копирует атрибуты из оригинальной функции в функцию-обёртку. Вот что именно копируется:

__module__ — модуль, в котором была определена оригинальная функция.
__name__ — имя оригинальной функции.
__qualname__ — квалифицированное имя оригинальной функции (важно для вложенных функций и классов).
__doc__ — строка документации (docstring).
__annotations__ — аннотации типов.
Применение @functools.wraps делает декораторы более "прозрачными" и позволяет сохранять все важные метаданные оригинальной функции, что повышает удобство и читаемость кода.






